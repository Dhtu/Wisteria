#!/usr/bin/sudo python


from bcc import BPF
from kafka import KafkaProducer
import argparse
import socket

parser = argparse.ArgumentParser(
    description="Trace TCP connects",
    formatter_class=argparse.RawDescriptionHelpFormatter,
    epilog=examples)
parser.add_argument("-p", "--pid",
                    help="trace this PID only")
parser.add_argument("-P", "--port",
                    help="comma-separated list of destination ports to trace.")
parser.add_argument("-U", "--print-uid", action="store_true",
                    help="include UID on output")
parser.add_argument("-u", "--uid",
                    help="trace this UID only")
parser.add_argument("--cgroupmap",
                    help="trace cgroups in this BPF map only")
parser.add_argument("--mntnsmap",
                    help="trace mount namespaces in this BPF map only")
parser.add_argument("--ebpf", action="store_true",
                    help=argparse.SUPPRESS)
args = parser.parse_args()

producer = KafkaProducer(bootstrap_servers=['localhost:9092'])
hostname = socket.gethostname()
ip = socket.gethostbyname(hostname)

# define BPF program
prog = """
#include <linux/sched.h>

// define output data structure in C
struct data_t {
    u32 pid;
    u64 ts;
    char comm[TASK_COMM_LEN];
};
BPF_PERF_OUTPUT(events);

int hello(struct pt_regs *ctx) {
    struct data_t data = {};

    data.pid = bpf_get_current_pid_tgid();
    data.ts = bpf_ktime_get_ns();
    bpf_get_current_comm(&data.comm, sizeof(data.comm));


    events.perf_submit(ctx, &data, sizeof(data));

    return 0;
}
"""

# load BPF program
b = BPF(text=prog)
b.attach_kprobe(event=b.get_syscall_fnname("read"), fn_name="hello")

# header
print("%-18s %-16s %-6s %s" % ("TIME(s)", "COMM", "PID", "MESSAGE"))

# process event
start = 0


def print_event(cpu, data, size):
    global start
    event = b["events"].event(data)
    if start == 0:
        start = event.ts
    event_common = b"%-16s" % event.comm
    if event.comm != b"java" and \
            event_common != b"data-plane-kafk " and \
            event_common != b"QXcbEventQueue  " and \
            event_common != b"konsole         ":
        event_text = b"%-9.3f" % ((float(event.ts) - start) / 1000000)
        event_text += b" %-16s %-6d" % (event.comm, event.pid)
        event_text += b" read "
        event_text += bytes(ip, encoding="utf8")

        producer.send('quickstart-events', key=None, value=event_text, partition=0)


# loop with callback to print_event
b["events"].open_perf_buffer(print_event)
while True:
    try:
        b.perf_buffer_poll()
    except KeyboardInterrupt:
        exit()