#!/usr/bin/sudo python


from bcc import BPF
from bcc.containers import filter_by_containers
from kafka import KafkaProducer
import argparse
import socket


# arguments todo
examples = """examples:
    ./tcpconnect           # trace all TCP connect()s
    ./tcpconnect -d        # include DNS queries associated with connects
    ./tcpconnect -p 181    # only trace PID 181
    ./tcpconnect -P 80     # only trace port 80
    ./tcpconnect -P 80,81  # only trace port 80 and 81
    ./tcpconnect -U        # include UID
    ./tcpconnect -u 1000   # only trace UID 1000
    ./tcpconnect -c        # count connects per src ip and dest ip/port
    ./tcpconnect --cgroupmap mappath  # only trace cgroups in this BPF map
    ./tcpconnect --mntnsmap mappath   # only trace mount namespaces in the map
"""
parser = argparse.ArgumentParser(
    description="Trace TCP connects",
    formatter_class=argparse.RawDescriptionHelpFormatter,
    epilog=examples)
parser.add_argument("-p", "--pid",
    help="trace this PID only")
parser.add_argument("-P", "--port",
    help="comma-separated list of destination ports to trace.")
parser.add_argument("-U", "--print-uid", action="store_true",
    help="include UID on output")
parser.add_argument("-u", "--uid",
    help="trace this UID only")
parser.add_argument("--cgroupmap",
    help="trace cgroups in this BPF map only")
parser.add_argument("--mntnsmap",
    help="trace mount namespaces in this BPF map only")
parser.add_argument("--ebpf", action="store_true",
    help=argparse.SUPPRESS)
args = parser.parse_args()


producer = KafkaProducer(bootstrap_servers=['localhost:9092'])
hostname = socket.gethostname()
ip = socket.gethostbyname(hostname)


# define BPF program
prog = """
#include <linux/sched.h>

// define output data structure in C
struct data_t {
    u32 pid;
    u64 ts;
    char comm[TASK_COMM_LEN];
};
BPF_PERF_OUTPUT(events);

int sys_write_entry(struct pt_regs *ctx) {
    struct data_t data = {};

    data.pid = bpf_get_current_pid_tgid();
    data.ts = bpf_ktime_get_ns();
    bpf_get_current_comm(&data.comm, sizeof(data.comm));
    

    events.perf_submit(ctx, &data, sizeof(data));

    return 0;
}
"""

prog = filter_by_containers(args) + prog

# load BPF program
b = BPF(text=prog)
b.attach_kprobe(event=b.get_syscall_fnname("write"), fn_name="sys_write_entry")

# header
print("Start monitoring the sys_write system call")

# process event
start = 0
def print_event(cpu, data, size):
    global start
    event = b["events"].event(data)
    if start == 0:
            start = event.ts
    event_common = b"%-16s" % event.comm
    if event.comm != b"java" and\
            event_common != b"data-plane-kafk " and\
            event_common != b"QXcbEventQueue  " and\
            event_common != b"konsole         ":
        event_text = b"%-9.3f" % ((float(event.ts) - start) / 1000000)
        event_text += b" %-16s %-6d" % (event.comm, event.pid)
        event_text += b" write "
        event_text += bytes(ip,encoding="utf8")


        producer.send('quickstart-events', key=None, value=event_text, partition=0)

# loop with callback to print_event
b["events"].open_perf_buffer(print_event)
while True:
    try:
        b.perf_buffer_poll()
    except KeyboardInterrupt:
        exit()