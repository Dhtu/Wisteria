# !/usr/bin/python


from bcc import BPF
from bcc.containers import filter_by_containers
from kafka import KafkaProducer
import argparse
import socket

# arguments
examples = """examples:
    ./tcpconnect           # trace all TCP connect()s
    ./tcpconnect -d        # include DNS queries associated with connects
    ./tcpconnect -p 181    # only trace PID 181
    ./tcpconnect -P 80     # only trace port 80
    ./tcpconnect -P 80,81  # only trace port 80 and 81
    ./tcpconnect -U        # include UID
    ./tcpconnect -u 1000   # only trace UID 1000
    ./tcpconnect -c        # count connects per src ip and dest ip/port
    ./tcpconnect --cgroupmap mappath  # only trace cgroups in this BPF map
    ./tcpconnect --mntnsmap mappath   # only trace mount namespaces in the map
"""

parser = argparse.ArgumentParser(
    description="Trace TCP connects",
    formatter_class=argparse.RawDescriptionHelpFormatter,
    epilog=examples)
parser.add_argument("-p", "--pid",
                    help="trace this PID only")
parser.add_argument("-P", "--port",
                    help="comma-separated list of destination ports to trace.")
parser.add_argument("-U", "--print-uid", action="store_true",
                    help="include UID on output")
parser.add_argument("-u", "--uid",
                    help="trace this UID only")
parser.add_argument("--cgroupmap",
                    help="trace cgroups in this BPF map only")
parser.add_argument("--mntnsmap",
                    help="trace mount namespaces in this BPF map only")
parser.add_argument("--ebpf", action="store_true",
                    help=argparse.SUPPRESS)
args = parser.parse_args()

producer = KafkaProducer(bootstrap_servers=['172.17.0.1:9092'])
hostname = socket.gethostname()
ip = socket.gethostbyname(hostname)

# todo: 可能把pid与tgid弄混了，需要后续验证


# define BPF program
prog = """
#include <linux/sched.h>

// define output data structure in C
struct data_write {
    u32 pid;
    u64 ts;
    char comm[TASK_COMM_LEN];
};
BPF_PERF_OUTPUT(write_events);

struct data_read {
    u32 pid;
    u64 ts;
    char comm[TASK_COMM_LEN];
};
BPF_PERF_OUTPUT(read_events);

int sys_write_entry(struct pt_regs *ctx) {

    if (container_should_be_filtered()) {
        return 0;
    }

    struct data_write data = {};

    data.pid = bpf_get_current_pid_tgid();
    data.ts = bpf_ktime_get_ns();
    bpf_get_current_comm(&data.comm, sizeof(data.comm));


    write_events.perf_submit(ctx, &data, sizeof(data));

    return 0;
}

int sys_read_entry(struct pt_regs *ctx) {


    if (container_should_be_filtered()) {
        return 0;
    }


    struct data_read data = {};

    data.pid = bpf_get_current_pid_tgid();
    data.ts = bpf_ktime_get_ns();
    bpf_get_current_comm(&data.comm, sizeof(data.comm));


    read_events.perf_submit(ctx, &data, sizeof(data));

    return 0;
}
"""

prog = filter_by_containers(args) + prog

# load BPF program
b = BPF(text=prog)
b.attach_kprobe(event=b.get_syscall_fnname("write"), fn_name="sys_write_entry")
b.attach_kprobe(event=b.get_syscall_fnname("read"), fn_name="sys_read_entry")

# header
print("Start monitoring the sys_write system call")

# process event
start = 0


def print_write_event(cpu, data, size):
    global start
    event = b["write_events"].event(data)
    if start == 0:
        start = event.ts
    if event.comm != b"bash":
        event_text = b"%-9.3f" % ((float(event.ts) - start) / 1000000)
        event_text += b" %-16s %-6d" % (event.comm, event.pid)
        event_text += b" write "
        event_text += bytes(ip, encoding="utf8")

        producer.send('tps', key=None, value=event_text, partition=0)


def print_read_event(cpu, data, size):
    global start
    event = b["read_events"].event(data)
    if start == 0:
        start = event.ts
    if event.comm != b"bash":
        event_text = b"%-9.3f" % ((float(event.ts) - start) / 1000000)
        event_text += b" %-16s %-6d" % (event.comm, event.pid)
        event_text += b" read "
        event_text += bytes(ip, encoding="utf8")

        producer.send('tps', key=None, value=event_text, partition=0)


# loop with callback to print_event
b["write_events"].open_perf_buffer(print_write_event)
b["read_events"].open_perf_buffer(print_read_event)



while True:
    try:
        b.perf_buffer_poll()
    except KeyboardInterrupt:
        exit()
